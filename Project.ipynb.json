{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 158,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from pandas import Series, DataFrame"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 159,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def dis(a,b):\n",
    "    d=np.sum((a[None,:] - b[:, None])**2, -1)**0.5\n",
    "    return d"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 160,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def cost(a,b):\n",
    "    return sum(dis(a,b).min(axis=0))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 187,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "def modelcost(center,cluster):\n",
    "    tot=[sum(dis(center[i],cluster[i])) for i in range(len(center))]\n",
    "    return sum(tot)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 161,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "def kmeans(data, ncenter, center, maxiter=1000, maxtol=10e-5):\n",
    "    centroids=[center]\n",
    "    i = 0\n",
    "    diff=100\n",
    "    while (diff>maxtol and i<maxiter):\n",
    "        # assign data points to clusters\n",
    "        \n",
    "        index=np.argmin(dis(data,centroids[i]),axis=0)\n",
    "        \n",
    "        clusters=[data[index==i] for i in range(ncenter)]\n",
    "\n",
    "        # recalculate centroids\n",
    "        centroids.append(np.concatenate([np.mean(cluster,axis=0) for cluster in clusters]).reshape(ncenter,-1))\n",
    "        diff=sum(np.sum((centroids[i+1]-centroids[i])**2,-1)**0.5)\n",
    "        i+= 1\n",
    "\n",
    "    return centroids, clusters,i"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 162,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "def kpp(x,k,weight=1):\n",
    "    index=[]\n",
    "    index.append(np.random.choice(x.shape[0],1)[0])\n",
    "    while(len(index)<k):\n",
    "        prob=dis(x,x[index,]).min(axis=0)*weight/sum(dis(x,x[index,]).min(axis=0)*weight)  \n",
    "        index.append(np.random.choice(x.shape[0],1,p=prob)[0])\n",
    "    return x[index,]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 163,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def kII(x,k,l):\n",
    "    index=set()\n",
    "    index.add(np.random.choice(x.shape[0],1)[0])\n",
    "    cost=sum(dis(x,x[list(index),]).min(axis=0))\n",
    "    i=1\n",
    "    while (i<np.log(cost)):\n",
    "        prob=dis(x,x[list(index),]).min(axis=0)/sum(dis(x,x[list(index),]).min(axis=0)) \n",
    "        cp=np.random.choice(x.shape[0],l,p=prob,replace=True)\n",
    "        index=index.union(set(cp))\n",
    "        i=i+1\n",
    "    center0=x[list(index),]\n",
    "    w=np.sum(np.argsort(dis(center0,center0),axis=1)==1,axis=0)\n",
    "    center1=kpp(center0,k,w)\n",
    "    return center1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 164,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "#simulation\n",
    "def simudata(ncenter,nsize,dim):\n",
    "    mean=[0]*dim\n",
    "    cov=np.diag(np.random.choice([1,10,100],dim,replace=True))\n",
    "    center=np.random.multivariate_normal(mean, cov, ncenter)\n",
    "    s=np.random.multivariate_normal(center[0,], np.eye(dim),nsize)\n",
    "    sample=np.concatenate((s, 0*np.ones(nsize)[:,None]), axis=1)\n",
    "    for i in range(ncenter-1):\n",
    "        s=np.random.multivariate_normal(center[i+1,], np.eye(dim),nsize)\n",
    "        s=np.concatenate((s, (i+1)*np.ones(nsize)[:,None]), axis=1)\n",
    "        sample=np.concatenate((sample,s),axis=0)\n",
    "    return center, sample"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 165,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "center, sample=simudata(20,1000,15)\n",
    "sample\n",
    "data=sample[:,0:15]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 166,
   "metadata": {
    "collapsed": false,
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "center0=kpp(sample[:,0:15],20)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 167,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "center1=kII(sample[:,0:15],20,10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 168,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "center,cluster, iter=kmeans(data, ncenter=20, center=center1, maxiter=1000, maxtol=10e-5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 189,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([ 122006.90388946])"
      ]
     },
     "execution_count": 189,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "modelcost(center[-1],cluster)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 190,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/aprilwang/anaconda/lib/python3.5/site-packages/numpy/core/_methods.py:59: RuntimeWarning: Mean of empty slice.\n",
      "  warnings.warn(\"Mean of empty slice.\", RuntimeWarning)\n"
     ]
    }
   ],
   "source": [
    "center,cluster, iter=kmeans(data, ncenter=20, center=center0, maxiter=1000, maxtol=10e-5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
